/*
 * TencentBlueKing is pleased to support the open source community by making
 * 蓝鲸智云 - 微网关(BlueKing - Micro APIGateway) available.
 * Copyright (C) 2025 Tencent. All rights reserved.
 * Licensed under the MIT License (the "License"); you may not use this file except
 * in compliance with the License. You may obtain a copy of the License at
 *
 *     http://opensource.org/licenses/MIT
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,
 * either express or implied. See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * We undertake not to change the open source license (MIT license) applicable
 * to the current version of the project delivered to anyone in the future.
 */

// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.

package repo

import (
	"context"
	"database/sql"

	"gorm.io/gorm"

	"gorm.io/gen"

	"gorm.io/plugin/dbresolver"
)

// Q ...
var (
	Q                                = new(Query)
	Consumer                         *consumer
	ConsumerGroup                    *consumerGroup
	Gateway                          *gateway
	GatewayCustomPluginSchema        *gatewayCustomPluginSchema
	GatewayReleaseVersion            *gatewayReleaseVersion
	GatewayResourceSchemaAssociation *gatewayResourceSchemaAssociation
	GatewaySyncData                  *gatewaySyncData
	GlobalRule                       *globalRule
	OperationAuditLog                *operationAuditLog
	PluginConfig                     *pluginConfig
	PluginMetadata                   *pluginMetadata
	Proto                            *proto
	Route                            *route
	SSL                              *sSL
	Service                          *service
	StreamRoute                      *streamRoute
	SystemConfig                     *systemConfig
	Upstream                         *upstream
)

// SetDefault ...
func SetDefault(db *gorm.DB, opts ...gen.DOOption) {
	*Q = *Use(db, opts...)
	Consumer = &Q.Consumer
	ConsumerGroup = &Q.ConsumerGroup
	Gateway = &Q.Gateway
	GatewayCustomPluginSchema = &Q.GatewayCustomPluginSchema
	GatewayReleaseVersion = &Q.GatewayReleaseVersion
	GatewayResourceSchemaAssociation = &Q.GatewayResourceSchemaAssociation
	GatewaySyncData = &Q.GatewaySyncData
	GlobalRule = &Q.GlobalRule
	OperationAuditLog = &Q.OperationAuditLog
	PluginConfig = &Q.PluginConfig
	PluginMetadata = &Q.PluginMetadata
	Proto = &Q.Proto
	Route = &Q.Route
	SSL = &Q.SSL
	Service = &Q.Service
	StreamRoute = &Q.StreamRoute
	SystemConfig = &Q.SystemConfig
	Upstream = &Q.Upstream
}

// Use ...
func Use(db *gorm.DB, opts ...gen.DOOption) *Query {
	return &Query{
		db:                               db,
		Consumer:                         newConsumer(db, opts...),
		ConsumerGroup:                    newConsumerGroup(db, opts...),
		Gateway:                          newGateway(db, opts...),
		GatewayCustomPluginSchema:        newGatewayCustomPluginSchema(db, opts...),
		GatewayReleaseVersion:            newGatewayReleaseVersion(db, opts...),
		GatewayResourceSchemaAssociation: newGatewayResourceSchemaAssociation(db, opts...),
		GatewaySyncData:                  newGatewaySyncData(db, opts...),
		GlobalRule:                       newGlobalRule(db, opts...),
		OperationAuditLog:                newOperationAuditLog(db, opts...),
		PluginConfig:                     newPluginConfig(db, opts...),
		PluginMetadata:                   newPluginMetadata(db, opts...),
		Proto:                            newProto(db, opts...),
		Route:                            newRoute(db, opts...),
		SSL:                              newSSL(db, opts...),
		Service:                          newService(db, opts...),
		StreamRoute:                      newStreamRoute(db, opts...),
		SystemConfig:                     newSystemConfig(db, opts...),
		Upstream:                         newUpstream(db, opts...),
	}
}

// Query ...
type Query struct {
	db *gorm.DB

	Consumer                         consumer
	ConsumerGroup                    consumerGroup
	Gateway                          gateway
	GatewayCustomPluginSchema        gatewayCustomPluginSchema
	GatewayReleaseVersion            gatewayReleaseVersion
	GatewayResourceSchemaAssociation gatewayResourceSchemaAssociation
	GatewaySyncData                  gatewaySyncData
	GlobalRule                       globalRule
	OperationAuditLog                operationAuditLog
	PluginConfig                     pluginConfig
	PluginMetadata                   pluginMetadata
	Proto                            proto
	Route                            route
	SSL                              sSL
	Service                          service
	StreamRoute                      streamRoute
	SystemConfig                     systemConfig
	Upstream                         upstream
}

// Available ...
func (q *Query) Available() bool { return q.db != nil }

func (q *Query) clone(db *gorm.DB) *Query {
	return &Query{
		db:                               db,
		Consumer:                         q.Consumer.clone(db),
		ConsumerGroup:                    q.ConsumerGroup.clone(db),
		Gateway:                          q.Gateway.clone(db),
		GatewayCustomPluginSchema:        q.GatewayCustomPluginSchema.clone(db),
		GatewayReleaseVersion:            q.GatewayReleaseVersion.clone(db),
		GatewayResourceSchemaAssociation: q.GatewayResourceSchemaAssociation.clone(db),
		GatewaySyncData:                  q.GatewaySyncData.clone(db),
		GlobalRule:                       q.GlobalRule.clone(db),
		OperationAuditLog:                q.OperationAuditLog.clone(db),
		PluginConfig:                     q.PluginConfig.clone(db),
		PluginMetadata:                   q.PluginMetadata.clone(db),
		Proto:                            q.Proto.clone(db),
		Route:                            q.Route.clone(db),
		SSL:                              q.SSL.clone(db),
		Service:                          q.Service.clone(db),
		StreamRoute:                      q.StreamRoute.clone(db),
		SystemConfig:                     q.SystemConfig.clone(db),
		Upstream:                         q.Upstream.clone(db),
	}
}

// ReadDB ...
func (q *Query) ReadDB() *Query {
	return q.ReplaceDB(q.db.Clauses(dbresolver.Read))
}

// WriteDB ...
func (q *Query) WriteDB() *Query {
	return q.ReplaceDB(q.db.Clauses(dbresolver.Write))
}

// ReplaceDB ...
func (q *Query) ReplaceDB(db *gorm.DB) *Query {
	return &Query{
		db:                               db,
		Consumer:                         q.Consumer.replaceDB(db),
		ConsumerGroup:                    q.ConsumerGroup.replaceDB(db),
		Gateway:                          q.Gateway.replaceDB(db),
		GatewayCustomPluginSchema:        q.GatewayCustomPluginSchema.replaceDB(db),
		GatewayReleaseVersion:            q.GatewayReleaseVersion.replaceDB(db),
		GatewayResourceSchemaAssociation: q.GatewayResourceSchemaAssociation.replaceDB(db),
		GatewaySyncData:                  q.GatewaySyncData.replaceDB(db),
		GlobalRule:                       q.GlobalRule.replaceDB(db),
		OperationAuditLog:                q.OperationAuditLog.replaceDB(db),
		PluginConfig:                     q.PluginConfig.replaceDB(db),
		PluginMetadata:                   q.PluginMetadata.replaceDB(db),
		Proto:                            q.Proto.replaceDB(db),
		Route:                            q.Route.replaceDB(db),
		SSL:                              q.SSL.replaceDB(db),
		Service:                          q.Service.replaceDB(db),
		StreamRoute:                      q.StreamRoute.replaceDB(db),
		SystemConfig:                     q.SystemConfig.replaceDB(db),
		Upstream:                         q.Upstream.replaceDB(db),
	}
}

type queryCtx struct {
	Consumer                         IConsumerDo
	ConsumerGroup                    IConsumerGroupDo
	Gateway                          IGatewayDo
	GatewayCustomPluginSchema        IGatewayCustomPluginSchemaDo
	GatewayReleaseVersion            IGatewayReleaseVersionDo
	GatewayResourceSchemaAssociation IGatewayResourceSchemaAssociationDo
	GatewaySyncData                  IGatewaySyncDataDo
	GlobalRule                       IGlobalRuleDo
	OperationAuditLog                IOperationAuditLogDo
	PluginConfig                     IPluginConfigDo
	PluginMetadata                   IPluginMetadataDo
	Proto                            IProtoDo
	Route                            IRouteDo
	SSL                              ISSLDo
	Service                          IServiceDo
	StreamRoute                      IStreamRouteDo
	SystemConfig                     ISystemConfigDo
	Upstream                         IUpstreamDo
}

// WithContext ...
func (q *Query) WithContext(ctx context.Context) *queryCtx {
	return &queryCtx{
		Consumer:                         q.Consumer.WithContext(ctx),
		ConsumerGroup:                    q.ConsumerGroup.WithContext(ctx),
		Gateway:                          q.Gateway.WithContext(ctx),
		GatewayCustomPluginSchema:        q.GatewayCustomPluginSchema.WithContext(ctx),
		GatewayReleaseVersion:            q.GatewayReleaseVersion.WithContext(ctx),
		GatewayResourceSchemaAssociation: q.GatewayResourceSchemaAssociation.WithContext(ctx),
		GatewaySyncData:                  q.GatewaySyncData.WithContext(ctx),
		GlobalRule:                       q.GlobalRule.WithContext(ctx),
		OperationAuditLog:                q.OperationAuditLog.WithContext(ctx),
		PluginConfig:                     q.PluginConfig.WithContext(ctx),
		PluginMetadata:                   q.PluginMetadata.WithContext(ctx),
		Proto:                            q.Proto.WithContext(ctx),
		Route:                            q.Route.WithContext(ctx),
		SSL:                              q.SSL.WithContext(ctx),
		Service:                          q.Service.WithContext(ctx),
		StreamRoute:                      q.StreamRoute.WithContext(ctx),
		SystemConfig:                     q.SystemConfig.WithContext(ctx),
		Upstream:                         q.Upstream.WithContext(ctx),
	}
}

// Transaction ...
func (q *Query) Transaction(fc func(tx *Query) error, opts ...*sql.TxOptions) error {
	return q.db.Transaction(func(tx *gorm.DB) error { return fc(q.clone(tx)) }, opts...)
}

// Begin ...
func (q *Query) Begin(opts ...*sql.TxOptions) *QueryTx {
	tx := q.db.Begin(opts...)
	return &QueryTx{Query: q.clone(tx), Error: tx.Error}
}

// QueryTx ...
type QueryTx struct {
	*Query
	Error error
}

// Commit ...
func (q *QueryTx) Commit() error {
	return q.db.Commit().Error
}

// Rollback ...
func (q *QueryTx) Rollback() error {
	return q.db.Rollback().Error
}

// SavePoint ...
func (q *QueryTx) SavePoint(name string) error {
	return q.db.SavePoint(name).Error
}

// RollbackTo ...
func (q *QueryTx) RollbackTo(name string) error {
	return q.db.RollbackTo(name).Error
}
